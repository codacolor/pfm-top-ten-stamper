<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pre-Post Size & Stamp — Photo Flow Method</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: #ffffff;
    color: #1a1a1a;
    min-height: 100vh;
  }

  header {
    background: #ffffff;
    padding: 48px 32px 32px;
    text-align: center;
  }

  header img {
    height: 40px;
    width: auto;
    margin-bottom: 12px;
  }

  header h1 {
    font-size: 17px;
    font-weight: 500;
    letter-spacing: 0.02em;
    color: #999;
  }

  .container {
    max-width: 1100px;
    margin: 0 auto;
    padding: 32px 24px;
  }

  /* Drop zone */
  .drop-zone {
    border: 2px dashed #ddd;
    border-radius: 12px;
    padding: 80px 40px;
    text-align: center;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
    background: #fafafa;
  }

  .drop-zone.drag-over {
    border-color: #1a1a1a;
    background: #f5f5f5;
  }

  .drop-zone h2 {
    font-size: 22px;
    font-weight: 600;
    margin-bottom: 8px;
  }

  .drop-zone p {
    font-size: 14px;
    color: #777;
    margin-bottom: 20px;
  }

  .drop-zone .browse-btn {
    display: inline-block;
    padding: 10px 24px;
    background: #1a1a1a;
    color: #fff;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
  }

  .drop-zone .browse-btn:hover { background: #333; }

  .drop-zone .browse-btn:active { background: #000; }

  /* Error banner */
  .error-banner {
    display: none;
    background: #fef2f2;
    border: 1px solid #fca5a5;
    color: #991b1b;
    padding: 12px 20px;
    border-radius: 8px;
    margin-bottom: 20px;
    font-size: 14px;
  }

  .error-banner.visible { display: block; }

  /* Preview section */
  .preview-section { display: none; }
  .preview-section.visible { display: block; }

  .toolbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
    flex-wrap: wrap;
    gap: 12px;
  }

  .toolbar .info {
    font-size: 14px;
    color: #555;
  }

  .toolbar .actions { display: flex; gap: 10px; }

  .btn {
    padding: 10px 22px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: background 0.15s;
  }

  .btn-primary {
    background: #1a1a1a;
    color: #fff;
  }
  .btn-primary:hover { background: #333; }
  .btn-primary:disabled { background: #999; cursor: not-allowed; }

  .btn-secondary {
    background: #f5f5f5;
    color: #1a1a1a;
    border: 1px solid #e0e0e0;
  }
  .btn-secondary:hover { background: #eee; }

  .btn-tertiary {
    background: #555;
    color: #fff;
    border: 1px solid #444;
  }
  .btn-tertiary:hover { background: #666; }
  .btn-tertiary:disabled { background: #999; cursor: not-allowed; }

  /* Preview grid */
  .preview-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 12px;
  }

  @media (max-width: 768px) {
    .preview-grid { grid-template-columns: repeat(2, 1fr); }
  }

  @media (max-width: 480px) {
    .preview-grid { grid-template-columns: 1fr 1fr; }
  }

  .preview-card {
    background: #fff;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid #eee;
    transition: border-color 0.15s, box-shadow 0.15s;
    cursor: grab;
    position: relative;
  }

  .preview-card:active { cursor: grabbing; }

  .preview-card.drag-over-card {
    border-color: #1a1a1a;
    box-shadow: 0 0 0 2px rgba(26, 26, 26, 0.2);
  }

  .preview-card .thumb-wrap {
    width: 100%;
    aspect-ratio: 3/2;
    overflow: hidden;
    background: #eee;
  }

  .preview-card .thumb-wrap img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    pointer-events: none;
  }

  .preview-card .card-footer {
    padding: 8px 10px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .preview-card .card-number {
    font-weight: 700;
    font-size: 16px;
  }

  .preview-card .card-name {
    font-size: 11px;
    color: #999;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 60%;
    text-align: right;
  }

  .preview-card .reorder-btns {
    position: absolute;
    top: 6px;
    right: 6px;
    display: flex;
    gap: 3px;
    opacity: 0;
    transition: opacity 0.15s;
  }

  .preview-card:hover .reorder-btns { opacity: 1; }

  .reorder-btns button {
    width: 26px;
    height: 26px;
    border: none;
    border-radius: 4px;
    background: rgba(0,0,0,0.55);
    color: #fff;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
  }

  .reorder-btns button:hover { background: rgba(0,0,0,0.8); }

  /* Processing overlay */
  .processing-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(255,255,255,0.85);
    z-index: 100;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 16px;
  }

  .processing-overlay.visible {
    display: flex;
  }

  .processing-overlay .spinner {
    width: 36px;
    height: 36px;
    border: 3px solid #eee;
    border-top-color: #6B8AF2;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .processing-overlay p {
    font-size: 15px;
    color: #555;
  }

  /* Hidden file input */
  #file-input { display: none; }
</style>
</head>
<body>

<header>
  <img src="Branding/PFM Logo + Text - Transparent.png" alt="Photo Flow">
  <h1>Pre-Post Size & Stamp</h1>
</header>

<div class="container">
  <div class="error-banner" id="error-banner"></div>

  <div class="drop-zone" id="drop-zone">
    <h2>Drag your photos here</h2>
    <p>Drop 1–10 images (JPEG or PNG). They'll be numbered in order.</p>
    <p style="font-size: 12px; color: #aaa; margin-bottom: 20px;">All processing happens on your computer — nothing is uploaded.</p>
    <button class="browse-btn" id="browse-btn">Browse Files</button>
  </div>
  <input type="file" id="file-input" accept="image/jpeg,image/png,image/webp" multiple>

  <div class="preview-section" id="preview-section">
    <div class="toolbar">
      <span class="info" id="photo-count"></span>
      <div class="actions">
        <button class="btn btn-secondary" id="add-more-btn">Add More</button>
        <button class="btn btn-secondary" id="clear-btn">Clear All</button>
        <button class="btn btn-tertiary" id="download-no-text-btn">Download Without Settings</button>
        <button class="btn btn-primary" id="download-btn">Download All</button>
      </div>
    </div>
    <div class="preview-grid" id="preview-grid"></div>
  </div>
</div>

<div class="processing-overlay" id="processing-overlay">
  <div class="spinner"></div>
  <p id="processing-text">Processing photos...</p>
</div>

<script>
(function() {
  'use strict';

  // --- State ---
  let photos = []; // { file, img (HTMLImageElement), thumbUrl, exifBytes }

  // --- DOM refs ---
  const dropZone = document.getElementById('drop-zone');
  const fileInput = document.getElementById('file-input');
  const browseBtn = document.getElementById('browse-btn');
  const errorBanner = document.getElementById('error-banner');
  const previewSection = document.getElementById('preview-section');
  const previewGrid = document.getElementById('preview-grid');
  const photoCount = document.getElementById('photo-count');
  const downloadBtn = document.getElementById('download-btn');
  const downloadNoTextBtn = document.getElementById('download-no-text-btn');
  const clearBtn = document.getElementById('clear-btn');
  const addMoreBtn = document.getElementById('add-more-btn');
  const processingOverlay = document.getElementById('processing-overlay');
  const processingText = document.getElementById('processing-text');

  // --- Helpers ---
  function showError(msg) {
    errorBanner.textContent = msg;
    errorBanner.classList.add('visible');
    setTimeout(() => errorBanner.classList.remove('visible'), 5000);
  }

  function showProcessing(msg) {
    processingText.textContent = msg;
    processingOverlay.classList.add('visible');
  }

  function hideProcessing() {
    processingOverlay.classList.remove('visible');
  }

  function loadImage(file) {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      const reader = new FileReader();

      let exifBytes = null;
      let imageLoaded = false;
      let exifRead = false;

      function checkComplete() {
        if (imageLoaded && exifRead) {
          resolve({ file, img, thumbUrl: url, exifBytes });
        }
      }

      img.onload = () => {
        imageLoaded = true;
        checkComplete();
      };

      img.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error('Failed to load ' + file.name));
      };

      reader.onload = (e) => {
        try {
          const data = e.target.result;
          if (typeof piexif !== 'undefined') {
            exifBytes = piexif.load(data);
          }
        } catch (err) {
          // No EXIF data or error reading it - that's okay
        }
        exifRead = true;
        checkComplete();
      };

      reader.onerror = () => {
        exifRead = true;
        checkComplete();
      };

      img.src = url;
      reader.readAsDataURL(file);
    });
  }

  // --- Crop factor lookup ---
  function getCropFactor(make, model) {
    make = (make || '').toLowerCase().trim();
    model = (model || '').toLowerCase().trim();
    if (!make && !model) return null;

    // Smartphones — skip 35mm equiv entirely
    if (make.includes('apple') || make.includes('samsung') || make.includes('google') ||
        make.includes('huawei') || make.includes('xiaomi') || make.includes('oneplus') ||
        model.includes('iphone') || model.includes('ipad') || model.includes('pixel') ||
        model.includes('galaxy')) {
      return 'phone';
    }

    // Fujifilm
    if (make.includes('fuji')) {
      if (model.match(/gfx/)) return 0.79;  // Medium format
      return 1.5;  // X-series APS-C
    }

    // Hasselblad / Phase One — medium format
    if (make.includes('hasselblad') || make.includes('phase one')) return 0.79;

    // Canon
    if (make.includes('canon')) {
      // Full frame bodies
      if (model.match(/eos r($|\s|3|5|6|8|p)/i)) return 1.0;
      if (model.match(/eos-?1d/i)) return 1.0;
      if (model.match(/eos (5d|6d)/i)) return 1.0;
      // APS-C bodies
      if (model.match(/eos (r7|r10|r50|r100)/i)) return 1.6;
      if (model.match(/eos (7d|77d|80d|90d)/i)) return 1.6;
      if (model.match(/eos (rebel|kiss|\d{3,4}d)/i)) return 1.6;
      if (model.match(/eos m\d/i)) return 1.6;
      if (model.match(/powershot/i)) return 2.7;  // 1" compacts
      return 1.6;  // Default Canon = APS-C (most common for students)
    }

    // Nikon
    if (make.includes('nikon')) {
      // Full frame Z-mount (single digit or Zf)
      if (model.match(/z\s?[5-9]($|\s|ii)/i) || model.match(/zf/i)) return 1.0;
      // Full frame DSLRs
      if (model.match(/d[3-6]($|\s|s|x)/i)) return 1.0;
      if (model.match(/d(850|810|800|780|750|700|610|600|df)/i)) return 1.0;
      // APS-C Z-mount
      if (model.match(/z\s?(30|50|fc)/i)) return 1.5;
      // APS-C DSLRs
      if (model.match(/d\d{4}/)) return 1.5;  // D3xxx, D5xxx, D7xxx
      // 1" Nikon compacts
      if (model.match(/nikon 1|coolpix/i)) return 2.7;
      return 1.5;  // Default Nikon = APS-C
    }

    // Sony
    if (make.includes('sony')) {
      // Full frame
      if (model.match(/a[79]($|\s|[ris]|ii|iii|iv|v|c)/i)) return 1.0;  // A7, A9 series
      if (model.match(/a1($|\s|ii)/i)) return 1.0;
      if (model.match(/ilce-(7|9|1($|\s))/i)) return 1.0;
      // APS-C
      if (model.match(/a6\d{3}/i) || model.match(/ilce-6/i)) return 1.5;
      if (model.match(/zv-e10/i)) return 1.5;
      // 1" sensor compacts
      if (model.match(/rx10|rx100|dsc-rx1[0]/i)) return 2.7;
      // Full frame compacts
      if (model.match(/rx1($|\s|r)/i) || model.match(/dsc-rx1($|\s|r)/i)) return 1.0;
      return 1.5;
    }

    // Olympus / OM System — Micro Four Thirds
    if (make.includes('olympus') || make.match(/om (digital|system)/)) return 2.0;

    // Panasonic
    if (make.includes('panasonic')) {
      if (model.match(/dc-s[15]/i) || model.match(/lumix s/i)) return 1.0;  // L-mount full frame
      return 2.0;  // Lumix G-series = MFT
    }

    // Leica
    if (make.includes('leica')) {
      if (model.match(/cl|tl/i)) return 1.5;  // APS-C
      return 1.0;  // Most Leica = full frame
    }

    // Pentax / Ricoh
    if (make.includes('pentax') || make.includes('ricoh')) {
      if (model.match(/k-1/i) || model.match(/645/i)) return 1.0;
      if (model.match(/gr\s?iii/i)) return 1.5;
      return 1.5;  // Default Pentax = APS-C
    }

    return null;  // Unknown — don't guess
  }

  // --- Stamp logic ---
  function stampNumber(img, number, exifBytes, showMetadataText = true) {
    const canvas = document.createElement('canvas');
    const MAX_LONG_SIDE = 2048;
    const natW = img.naturalWidth;
    const natH = img.naturalHeight;

    // Calculate scale and canvas size (no EXIF rotation applied)
    const longSide = Math.max(natW, natH);
    const scale = longSide > MAX_LONG_SIDE ? MAX_LONG_SIDE / longSide : 1;
    canvas.width = Math.round(natW * scale);
    canvas.height = Math.round(natH * scale);
    const ctx = canvas.getContext('2d');

    // Draw the image as-is (EXIF only used for metadata text, not rotation)
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    // Small circle stamp in bottom-right corner
    const shortSide = Math.min(canvas.width, canvas.height);
    const circleRadius = Math.round(shortSide * 0.03);
    const inset = Math.round(circleRadius * 1.5);
    const cx = canvas.width - inset;
    const cy = canvas.height - inset;

    ctx.fillStyle = '#5275F6';
    ctx.beginPath();
    ctx.arc(cx, cy, circleRadius, 0, Math.PI * 2);
    ctx.fill();

    // Draw white number centered in circle
    const numberSize = Math.round(circleRadius * 1.2);
    ctx.font = 'bold ' + numberSize + 'px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(number), cx, cy);

    // Extract and draw metadata next to circle
    if (exifBytes && typeof piexif !== 'undefined') {
      try {
        const exifSub = exifBytes['Exif'] || {};

        // Build metadata text: 35mm equiv · aperture · shutter · ISO
        const focalLength35 = exifSub[piexif.ExifIFD.FocalLengthIn35mmFilm];
        const focalLength = exifSub[piexif.ExifIFD.FocalLength];
        const fNumber = exifSub[piexif.ExifIFD.FNumber];
        const expTime = exifSub[piexif.ExifIFD.ExposureTime];
        const iso = exifSub[piexif.ExifIFD.ISOSpeedRatings];

        let metaText = '';

        // Focal length and 35mm equiv
        if (focalLength) {
          const fl = Math.round(focalLength[0] / focalLength[1]);
          let fl35 = focalLength35;

          // If 35mm equiv missing from EXIF, calculate from crop factor
          if (!fl35) {
            const make = exifBytes['0th'] ? exifBytes['0th'][piexif.ImageIFD.Make] : null;
            const model = exifBytes['0th'] ? exifBytes['0th'][piexif.ImageIFD.Model] : null;
            const cropFactor = getCropFactor(make, model);

            if (cropFactor === 'phone') {
              // Smartphones: just show focal length, no equiv
              metaText = fl + 'mm';
            } else if (cropFactor !== null) {
              fl35 = Math.round(fl * cropFactor);
            }
          }

          // Build focal length text (if not already set by phone branch)
          if (!metaText) {
            if (fl35 && fl35 !== fl) {
              metaText = fl + 'mm (' + fl35 + 'mm)';
            } else {
              metaText = fl + 'mm';
            }
          }
        }

        // Aperture
        if (fNumber) {
          const f = (fNumber[0] / fNumber[1]).toFixed(1);
          metaText += (metaText ? ' · ' : '') + 'f/' + f;
        }

        // Shutter
        if (expTime) {
          const exp = expTime[0] / expTime[1];
          const expStr = exp >= 1 ? exp + 's' : '1/' + Math.round(1 / exp) + 's';
          metaText += (metaText ? ' · ' : '') + expStr;
        }

        // ISO
        if (iso) {
          metaText += (metaText ? ' · ' : '') + 'ISO ' + iso;
        }

        if (metaText && showMetadataText) {
          // Draw white text with drop shadow next to circle (thinner weight for subtlety)
          const metaFontSize = Math.round(circleRadius * 0.8);
          ctx.font = '500 ' + metaFontSize + 'px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';

          // Drop shadow
          ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
          ctx.shadowBlur = 4;
          ctx.shadowOffsetX = 1;
          ctx.shadowOffsetY = 1;

          // White text positioned to the left of the circle
          ctx.fillStyle = '#ffffff';
          ctx.textAlign = 'right';
          ctx.textBaseline = 'middle';
          ctx.fillText(metaText, cx - circleRadius - 12, cy);

          // Reset shadow
          ctx.shadowColor = 'transparent';
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
        }
      } catch (err) {
        console.warn('Failed to render EXIF metadata:', err);
      }
    }

    return canvas;
  }

  function canvasToBlob(canvas, exifBytes) {
    return new Promise(resolve => {
      const dataUrl = canvas.toDataURL('image/jpeg', 0.85);

      // If we have EXIF data, insert it back into the JPEG
      if (exifBytes && typeof piexif !== 'undefined') {
        try {
          // Reset orientation to 1 (normal) since canvas pixel data is already correctly oriented
          if (exifBytes['0th']) {
            exifBytes['0th'][piexif.ImageIFD.Orientation] = 1;
          }
          const exifStr = piexif.dump(exifBytes);
          const withExif = piexif.insert(exifStr, dataUrl);

          // Convert data URL to Blob
          fetch(withExif)
            .then(res => res.blob())
            .then(blob => resolve(blob));
        } catch (err) {
          // If EXIF insertion fails, fall back to image without EXIF
          console.warn('Failed to insert EXIF data:', err);
          fetch(dataUrl)
            .then(res => res.blob())
            .then(blob => resolve(blob));
        }
      } else {
        // No EXIF data, just convert to blob
        fetch(dataUrl)
          .then(res => res.blob())
          .then(blob => resolve(blob));
      }
    });
  }

  // --- Drag & drop (file input) ---
  dropZone.addEventListener('dragover', e => {
    e.preventDefault();
    dropZone.classList.add('drag-over');
  });

  dropZone.addEventListener('dragleave', () => {
    dropZone.classList.remove('drag-over');
  });

  dropZone.addEventListener('drop', e => {
    e.preventDefault();
    dropZone.classList.remove('drag-over');
    handleFiles(e.dataTransfer.files);
  });

  browseBtn.addEventListener('click', e => {
    e.stopPropagation();
    fileInput.click();
  });

  dropZone.addEventListener('click', () => {
    fileInput.click();
  });

  fileInput.addEventListener('change', () => {
    if (fileInput.files.length) handleFiles(fileInput.files);
    fileInput.value = '';
  });

  addMoreBtn.addEventListener('click', () => fileInput.click());

  async function handleFiles(fileList) {
    const validTypes = ['image/jpeg', 'image/png', 'image/webp'];
    const newFiles = Array.from(fileList).filter(f => validTypes.includes(f.type));

    if (newFiles.length === 0) {
      showError('No valid images found. Please use JPEG, PNG, or WebP files.');
      return;
    }

    const totalAfterAdd = photos.length + newFiles.length;
    if (totalAfterAdd > 10) {
      showError('Maximum 10 photos allowed. You have ' + photos.length + ', tried to add ' + newFiles.length + '.');
      return;
    }

    showProcessing('Loading ' + newFiles.length + ' photo' + (newFiles.length > 1 ? 's' : '') + '...');

    try {
      for (const file of newFiles) {
        const loaded = await loadImage(file);
        photos.push(loaded);
      }
      renderPreview();
    } catch (err) {
      showError(err.message);
    }

    hideProcessing();
  }

  // --- Preview rendering ---
  function renderPreview() {
    if (photos.length === 0) {
      previewSection.classList.remove('visible');
      dropZone.style.display = '';
      return;
    }

    dropZone.style.display = 'none';
    previewSection.classList.add('visible');
    photoCount.textContent = photos.length + ' photo' + (photos.length !== 1 ? 's' : '') + ' — drag to reorder';
    previewGrid.innerHTML = '';

    photos.forEach((photo, i) => {
      const card = document.createElement('div');
      card.className = 'preview-card';
      card.draggable = true;
      card.dataset.index = i;

      // Thumbnail with stamp preview
      const thumbWrap = document.createElement('div');
      thumbWrap.className = 'thumb-wrap';
      const img = document.createElement('img');
      img.src = photo.thumbUrl;
      img.alt = 'Photo ' + (i + 1);
      thumbWrap.appendChild(img);

      // Reorder buttons (fallback for touch)
      const reorderBtns = document.createElement('div');
      reorderBtns.className = 'reorder-btns';
      if (i > 0) {
        const leftBtn = document.createElement('button');
        leftBtn.innerHTML = '&#8592;';
        leftBtn.title = 'Move left';
        leftBtn.addEventListener('click', e => { e.stopPropagation(); movePhoto(i, i - 1); });
        reorderBtns.appendChild(leftBtn);
      }
      if (i < photos.length - 1) {
        const rightBtn = document.createElement('button');
        rightBtn.innerHTML = '&#8594;';
        rightBtn.title = 'Move right';
        rightBtn.addEventListener('click', e => { e.stopPropagation(); movePhoto(i, i + 1); });
        reorderBtns.appendChild(rightBtn);
      }
      card.appendChild(reorderBtns);

      // Footer
      const footer = document.createElement('div');
      footer.className = 'card-footer';
      const numSpan = document.createElement('span');
      numSpan.className = 'card-number';
      numSpan.textContent = String(i + 1).padStart(2, '0');
      const nameSpan = document.createElement('span');
      nameSpan.className = 'card-name';
      nameSpan.textContent = photo.file.name;
      footer.appendChild(numSpan);
      footer.appendChild(nameSpan);

      card.appendChild(thumbWrap);
      card.appendChild(footer);

      // Drag events for reordering
      card.addEventListener('dragstart', onDragStart);
      card.addEventListener('dragover', onDragOver);
      card.addEventListener('dragleave', onDragLeave);
      card.addEventListener('drop', onCardDrop);
      card.addEventListener('dragend', onDragEnd);

      previewGrid.appendChild(card);
    });

    // Show add-more button only if under 10
    addMoreBtn.style.display = photos.length < 10 ? '' : 'none';
  }

  function movePhoto(from, to) {
    const [item] = photos.splice(from, 1);
    photos.splice(to, 0, item);
    renderPreview();
  }

  // --- Drag-and-drop reorder ---
  let dragIndex = null;

  function onDragStart(e) {
    dragIndex = parseInt(this.dataset.index);
    this.style.opacity = '0.4';
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', dragIndex);
  }

  function onDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    this.classList.add('drag-over-card');
  }

  function onDragLeave() {
    this.classList.remove('drag-over-card');
  }

  function onCardDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    this.classList.remove('drag-over-card');
    const toIndex = parseInt(this.dataset.index);
    if (dragIndex !== null && dragIndex !== toIndex) {
      movePhoto(dragIndex, toIndex);
    }
    dragIndex = null;
  }

  function onDragEnd() {
    this.style.opacity = '';
    dragIndex = null;
    document.querySelectorAll('.preview-card').forEach(c => c.classList.remove('drag-over-card'));
  }

  // --- Download ---
  downloadBtn.addEventListener('click', async () => {
    if (photos.length === 0) return;

    downloadBtn.disabled = true;
    showProcessing('Stamping photo 1 of ' + photos.length + '...');

    try {
      const zip = new JSZip();

      for (let i = 0; i < photos.length; i++) {
        processingText.textContent = 'Stamping photo ' + (i + 1) + ' of ' + photos.length + '...';
        const canvas = stampNumber(photos[i].img, i + 1, photos[i].exifBytes, true);
        const blob = await canvasToBlob(canvas, photos[i].exifBytes);
        zip.file(String(i + 1).padStart(2, '0') + '.jpg', blob);

        // Yield to UI so the processing text updates
        await new Promise(r => setTimeout(r, 0));
      }

      processingText.textContent = 'Creating ZIP...';
      const zipBlob = await zip.generateAsync({ type: 'blob' });

      const today = new Date().toISOString().slice(0, 10);
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'top-10-stamped-' + today + '.zip';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (err) {
      showError('Download failed: ' + err.message);
    }

    hideProcessing();
    downloadBtn.disabled = false;
  });

  // --- Download without metadata text ---
  downloadNoTextBtn.addEventListener('click', async () => {
    if (photos.length === 0) return;

    downloadNoTextBtn.disabled = true;
    showProcessing('Stamping photo 1 of ' + photos.length + '...');

    try {
      const zip = new JSZip();

      for (let i = 0; i < photos.length; i++) {
        processingText.textContent = 'Stamping photo ' + (i + 1) + ' of ' + photos.length + '...';
        const canvas = stampNumber(photos[i].img, i + 1, photos[i].exifBytes, false);
        const blob = await canvasToBlob(canvas, photos[i].exifBytes);
        zip.file(String(i + 1).padStart(2, '0') + '.jpg', blob);

        // Yield to UI so the processing text updates
        await new Promise(r => setTimeout(r, 0));
      }

      processingText.textContent = 'Creating ZIP...';
      const zipBlob = await zip.generateAsync({ type: 'blob' });

      const today = new Date().toISOString().slice(0, 10);
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'top-10-stamped-no-settings-' + today + '.zip';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (err) {
      showError('Download failed: ' + err.message);
    }

    hideProcessing();
    downloadNoTextBtn.disabled = false;
  });

  // --- Clear ---
  clearBtn.addEventListener('click', () => {
    photos.forEach(p => URL.revokeObjectURL(p.thumbUrl));
    photos = [];
    renderPreview();
  });
})();
</script>
</body>
</html>
